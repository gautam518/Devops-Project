Directories in Linux
/bin-->
/usr/
/usr/bin/
/sbin/
/boot/
/lib/
/lib64/


1-/bin/
All the executable binary programs (file) required during booting, repairing, files required to run into single-user-mode, and other important, basic commands viz., cat, du, df, tar, rpm, wc, history, etc.
The /bin directory contains the essential user binaries (programs) that must be present when the system is mounted in single-user mode.Applications such as Firefox are stored in /usr/bin, while important system programs and utilities such as the bash shell are located in /bin. The /usr directory may be stored on another partition – placing these files in the /bin directory ensures the system will have these important utilities even if no other file systems are mounted. The /sbin directory is similar – it contains essential system administration binaries.

Single User Mode (sometimes known as Maintenance Mode) is a mode in Unix-like operating systems such as Linux operate, where a handful of services are started at system boot for basic functionality to enable a single superuser perform certain critical tasks.It is runlevel 1 under system SysV init, and runlevel1.target or rescue.target in systemd.It’s generally useful for maintenance or emergency repairs (since it doesn’t offer any network services at all), when a computer is not capable of normal operations.Some of the low-level repairs include running such as fsck of damaged disk partitions, reset root password if you have lost it, fix “failed to mount /etc/fstab” error – just to mention the most critical of them. And also when the system fails to boot normally.

2-/usr/-->User Binaries & Read-Only Data
Contains executable binaries, documentation, source code, libraries for second level program.
The /usr directory contains applications and files used by users, as opposed to applications and files used by the system. For example, non-essential applications are located inside the /usr/bin directory instead of the /bin directory and non-essential system administration binaries are located in the /usr/sbin directory instead of the /sbin directory. Libraries for each are located inside the /usr/lib directory. The /usr directory also contains other directories – for example, architecture-independent files like graphics are located in /usr/share.

The /usr/local directory is where locally compiled applications install to by default – this prevents them from mucking up the rest of the system.

3-/sbin/
Contains binary executable programs, required by System Administrator, for Maintenance. Viz., iptables, fdisk, ifconfig, swapon, reboot, etc.
The /sbin directory is similar to the /bin directory. It contains essential binaries that are generally intended to be run by the root user for system administration.

4-/boot/---------> static boot files
Holds important files during boot-up process, including Linux Kernel.
The /boot directory contains the files needed to boot the system – for example, the GRUB boot loader’s files and your Linux kernels are stored here. The boot loader’s configuration files aren’t located here, though – they’re in /etc with the other configuration files.

5-/dev/
Contains device files for all the hardware devices on the machine e.g., cdrom, cpu, etc.
Linux exposes devices as files, and the /dev directory contains a number of special files that represent devices. These are not actual files as we know them, but they appear as files – for example, /dev/sda represents the first SATA drive in the system. If you wanted to partition it, you could start a partition editor and tell it to edit /dev/sda.

This directory also contains pseudo-devices, which are virtual devices that don’t actually correspond to hardware. For example, /dev/random produces random numbers. /dev/null is a special device that produces no output and automatically discards all input – when you pipe the output of a command to /dev/null, you discard it.

6-/etc/
Contains Application’s configuration files, startup, shutdown, start, stop script for every individual program.

7-/lib/
The Lib directory contains kernel modules and shared library images required to boot the system and run commands in root file system.
he /lib directory contains libraries needed by the essential binaries in the /bin and /sbin folder. Libraries needed by the binaries in the /usr/bin folder are located in /usr/lib.

Binaries are files that contain compiled source code (or machine code). Binary files are the files which contain compiled source code (or machine code). They are also called executable files because they can be executed on the computer. Binary directory contains following directories: /bin




10 ways to determine binaries files in linux.
Binaries are files that contain compiled source code (or machine code). Binary files are the files which contain compiled source code (or machine code). They are also called executable files because they can be executed on the computer. Binary directory contains following directories: /bin

1-file
What it does: Help to determine the file type.

This will be your starting point for binary analysis. We work with files daily. Not everything is an executable type; there is a whole wide range of file types out there. Before you start, you need to understand the type of file that is being analyzed. Is it a binary file, a library file, an ASCII text file, a video file, a picture file, a PDF, a data file, etc.?

The file command will help you identify the exact file type that you are dealing with.

# file /bin/ls
/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=c8ada1f7095f6b2bb7ddc848e088c2d615c3743e, stripped

2-ldd
What it does: Print shared object dependencies.

If you have already used the file command above on an executable binary, you can't miss the "dynamically linked" message in the output. What does it mean?

When software is being developed, we try not to reinvent the wheel. There are a set of common tasks that most software programs require, like printing output or reading from standard in, or opening files, etc. All of these common tasks are abstracted away in a set of common functions that everybody can then use instead of writing their own variants. These common functions are put in a library called libc or glibc.

How does one find which libraries the executable is dependent on? That’s where ldd command comes into the picture. Running it against a dynamically linked binary shows all its dependent libraries and their paths.


 ldd /bin/ls
        linux-vdso.so.1 =>  (0x00007ffcfad96000)
        libselinux.so.1 => /lib64/libselinux.so.1 (0x00007ff6f8e6e000)
        libcap.so.2 => /lib64/libcap.so.2 (0x00007ff6f8c69000)
        libacl.so.1 => /lib64/libacl.so.1 (0x00007ff6f8a60000)
        libc.so.6 => /lib64/libc.so.6 (0x00007ff6f8692000)
        libpcre.so.1 => /lib64/libpcre.so.1 (0x00007ff6f8430000)
        libdl.so.2 => /lib64/libdl.so.2 (0x00007ff6f822c000)
        /lib64/ld-linux-x86-64.so.2 (0x00007ff6f9095000)
        libattr.so.1 => /lib64/libattr.so.1 (0x00007ff6f8027000)
        libpthread.so.0 => /lib64/libpthread.so.0 (0x00007ff6f7e0b000)

3-ltrace
ltrace--Yum install ltrace
What it does: A library call tracer.

We now know how to find the libraries an executable program is dependent on using the ldd command. However, a library can contain hundreds of functions. Out of those hundreds, which are the actual functions being used by our binary?

The ltrace command displays all the functions that are being called at run time from the library. In the below example, you can see the function names being called, along with the arguments being passed to that function. You can also see what was returned by those functions on the far right side of the output.

ltrace ls
__libc_start_main(0x402910, 1, 0x7ffcac0937e8, 0x4129a0 <unfinished ...>
strrchr("ls", '/')                                                                               = nil
setlocale(LC_ALL, "")                                                                            = "en_US.UTF-8"
bindtextdomain("coreutils", "/usr/share/locale")                                                 = "/usr/share/locale"
textdomain("coreutils")                                                                          = "coreutils"
__cxa_atexit(0x40a980, 0, 0, 0x736c6974756572)                                                   = 0
isatty(1)                                                                                        = 1
getenv("QUOTING_STYLE")                                                                          = nil
getenv("COLUMNS")                                                                                = nil
ioctl(1, 21523, 0x7ffcac0936b0)                                                                  = 0
getenv("TABSIZE")                                                                                = nil
getopt_long(1, 0x7ffcac0937e8, "abcdfghiklmnopqrstuvw:xABCDFGHI:"..., 0x61a640, -1)              = -1
getenv("LS_BLOCK_SIZE")                                                                          = nil
getenv("BLOCK_SIZE")                                                                             = nil
getenv("BLOCKSIZE")                                                                              = nil
getenv("POSIXLY_CORRECT")                                                                        = nil
getenv("BLOCK_SIZE")                                                                             = nil
__errno_location()                                                                               = 0x7f46132286c0
malloc(56)                                                                                       = 0x1ddb050
memcpy(0x1ddb050, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 56)     = 0x1ddb050
__errno_location()                                                                               = 0x7f46132286c0
malloc(56)                                                                                       = 0x1ddb090
memcpy(0x1ddb090, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 56)     = 0x1ddb090
malloc(19200)                                                                                    = 0x1ddb0d0
malloc(32)                                                                                       = 0x1ddfbe0







